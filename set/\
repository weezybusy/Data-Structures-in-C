#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#include "set.h"

void test_set(void);
void test_set_insert(void);
void test_set_remove(void);
void test_set_union(void);
void test_set_intersection(void);
void test_set_difference(void);
void test_set_is_member(void);
void test_set_is_subset(void);
void test_set_is_equal(void);
int compare(const void *value1, const void *value2);
void display_set(const set_t *set);
void create_set(set_t *set, int values[], size_t size);

int main(void)
{
        test_set();
        set_t set;
        set_create(&set, (int []){11, 22, 33, 44});
        return EXIT_SUCCESS;
}

void test_set(void)
{
        test_set_insert();
        test_set_remove();
        test_set_union();
        //test_set_intersection();
        //test_set_difference();
        //test_set_is_member();
        //test_set_is_subset();
        //test_set_is_equal();
}

void test_set_insert(void)
{
        set_t set;
        set_init(&set, compare, free);

        int *data1 = (int *) malloc(sizeof(int));
        int *data2 = (int *) malloc(sizeof(int));
        int *data3 = (int *) malloc(sizeof(int));

        assert(data1 != NULL);
        assert(data2 != NULL);
        assert(data3 != NULL);

        int val1 = 55;
        int val2 = 66;
        int val3 = 77;

        *data1 = val1;
        *data2 = val2;
        *data3 = val3;

        assert(set_size(&set) == 0);
        size_t size = set_size(&set);

        // Check adding a member to the empty set.
        assert(set_insert(&set, data1) != -1);
        assert(set_size(&set) == ++size);
        assert(*(int *) list_data(list_head(&set)) == val1);

        // Check adding member which is already in set.
        assert(set_insert(&set, data1) == 1);
        assert(set_size(&set) == size);

        // Check adding more members.
        assert(set_insert(&set, data2) != -1);
        assert(set_size(&set) == ++size);
        assert(*(int *) list_data(list_tail(&set)) == val2);

        assert(set_insert(&set, data3) != -1);
        assert(set_size(&set) == ++size);
        assert(*(int *) list_data(list_tail(&set)) == val3);

        printf("%-30s ok\n", __func__);
        set_destroy(&set);
}

void test_set_remove(void)
{
        set_t set;
        set_init(&set, compare, free);

        int *data1 = (int *) malloc(sizeof(int));
        int *data2 = (int *) malloc(sizeof(int));
        int *data3 = (int *) malloc(sizeof(int));
        int *data4 = (int *) malloc(sizeof(int));
        int *data5 = (int *) malloc(sizeof(int));

        assert(data1 != NULL);
        assert(data2 != NULL);
        assert(data3 != NULL);
        assert(data4 != NULL);
        assert(data5 != NULL);

        int val1 = 55;
        int val2 = 66;
        int val3 = 77;
        int val4 = 88;
        int val5 = 99;

        *data1 = val1;
        *data2 = val2;
        *data3 = val3;
        *data4 = val4;
        *data5 = val5;

        assert(set_size(&set) == 0);
        size_t size = set_size(&set);

        int *non_existing_data = (int *) malloc(sizeof(int));
        assert(non_existing_data != NULL);
        *non_existing_data = 11;

        // Check removing from the empty set.
        assert(set_remove(&set, NULL) == -1);

        assert(set_insert(&set, data1) != -1);
        assert(set_size(&set) == ++size);
        assert(*(int *) list_data(list_head(&set)) == val1);

        assert(set_insert(&set, data2) != -1);
        assert(set_size(&set) == ++size);
        assert(*(int *) list_data(list_tail(&set)) == val2);

        assert(set_insert(&set, data3) != -1);
        assert(set_size(&set) == ++size);
        assert(*(int *) list_data(list_tail(&set)) == val3);

        assert(set_insert(&set, data4) != -1);
        assert(set_size(&set) == ++size);
        assert(*(int *) list_data(list_tail(&set)) == val4);

        assert(set_insert(&set, data5) != -1);
        assert(set_size(&set) == ++size);
        assert(*(int *) list_data(list_tail(&set)) == val5);

        // Check removing a non-existing member.
        assert(set_remove(&set, (void **) &non_existing_data) == -1);
        assert(set_size(&set) == size);

        // Check removing valid data.
        assert(set_remove(&set, (void **) &data3) != -1);
        assert(set_size(&set) == --size);
        free(data3);

        assert(set_remove(&set, (void **) &data1) != -1);
        assert(set_size(&set) == --size);
        free(data1);

        assert(set_remove(&set, (void **) &data2) != -1);
        assert(set_size(&set) == --size);
        free(data2);

        assert(set_remove(&set, (void **) &data5) != -1);
        assert(set_size(&set) == --size);
        free(data5);

        assert(set_remove(&set, (void **) &data4) != -1);
        assert(set_size(&set) == --size);
        free(data4);

        printf("%-30s ok\n", __func__);
        free(non_existing_data);
        set_destroy(&set);
}

void test_set_union(void)
{
        set_t set1;
        set_t set2;
        set_t setu;
        //set_t set_check;

        int *data1 = NULL;
        int *data2 = NULL;
        int *data3 = NULL;
        int *data4 = NULL;
        int *data5 = NULL;
        int *data6 = NULL;
        //int *data7 = NULL;

        int val1 = 11;
        int val2 = 22;
        int val3 = 33;
        int val4 = 44;
        int val5 = 55;
        int val6 = 66;
        //int val7 = 77;

        size_t size = 0;

        // Chack union of two empty sets.
        set_init(&set1, compare, free);
        set_init(&set2, compare, free);

        assert(set_union(&setu, &set1, &set2) == 0);
        assert(set_size(&setu) == 0);

        set_destroy(&set1);
        set_destroy(&set2);
        set_destroy(&setu);

        // Check union of two sets where the first one is empty.
        set_init(&set1, compare, free);
        set_init(&set2, compare, free);

        data1 = (int *) malloc(sizeof(int));
        data2 = (int *) malloc(sizeof(int));
        data3 = (int *) malloc(sizeof(int));

        assert(data1 != NULL);
        assert(data2 != NULL);
        assert(data3 != NULL);

        *data1 = val1;
        *data2 = val2;
        *data3 = val3;

        assert(set_size(&set2) == 0);
        size = set_size(&set2);
        assert(set_insert(&set2, data1) != -1);
        assert(set_size(&set2) == ++size);
        assert(set_insert(&set2, data2) != -1);
        assert(set_size(&set2) == ++size);
        assert(set_insert(&set2, data3) != -1);
        assert(set_size(&set2) == ++size);

        assert(set_union(&setu, &set1, &set2) != -1);
        assert(set_size(&setu) == size);
        display_set(&setu);

        set_destroy(&set1);
        set_destroy(&set2);
        set_destroy(&setu);

        // Check union of two sets where the second one is empty.
        set_init(&set1, compare, free);
        set_init(&set2, compare, free);

        data1 = (int *) malloc(sizeof(int));
        data2 = (int *) malloc(sizeof(int));
        data3 = (int *) malloc(sizeof(int));

        assert(data1 != NULL);
        assert(data2 != NULL);
        assert(data3 != NULL);

        *data1 = val1;
        *data2 = val2;
        *data3 = val3;

        assert(set_size(&set1) == 0);
        size = set_size(&set1);
        assert(set_insert(&set1, data1) != -1);
        assert(set_size(&set1) == ++size);
        assert(set_insert(&set1, data2) != -1);
        assert(set_size(&set1) == ++size);
        assert(set_insert(&set1, data3) != -1);
        assert(set_size(&set1) == ++size);

        assert(set_union(&setu, &set1, &set2) != -1);
        assert(set_size(&setu) == size);
        display_set(&setu);

        set_destroy(&set1);
        set_destroy(&set2);
        set_destroy(&setu);

        // Check union of two sets with same sizes and different data.
        set_init(&set1, compare, free);
        set_init(&set2, compare, free);

        data1 = (int *) malloc(sizeof(int));
        data2 = (int *) malloc(sizeof(int));
        data3 = (int *) malloc(sizeof(int));
        data4 = (int *) malloc(sizeof(int));
        data5 = (int *) malloc(sizeof(int));
        data6 = (int *) malloc(sizeof(int));

        assert(data1 != NULL);
        assert(data2 != NULL);
        assert(data3 != NULL);
        assert(data4 != NULL);
        assert(data5 != NULL);
        assert(data6 != NULL);

        *data1 = val1;
        *data2 = val2;
        *data3 = val3;
        *data4 = val4;
        *data5 = val5;
        *data6 = val6;

        // Insert data into the first set.
        assert(set_size(&set1) == 0);
        size = set_size(&set1);
        assert(set_insert(&set1, data1) != -1);
        assert(set_size(&set1) == ++size);
        assert(set_insert(&set1, data2) != -1);
        assert(set_size(&set1) == ++size);
        assert(set_insert(&set1, data3) != -1);
        assert(set_size(&set1) == ++size);

        // Insert data into the second set.
        assert(set_size(&set2) == 0);
        size = set_size(&set2);
        assert(set_insert(&set2, data4) != -1);
        assert(set_size(&set2) == ++size);
        assert(set_insert(&set2, data5) != -1);
        assert(set_size(&set2) == ++size);
        assert(set_insert(&set2, data6) != -1);
        assert(set_size(&set2) == ++size);

        set_destroy(&set1);
        set_destroy(&set2);
        set_destroy(&setu);

        printf("%-30s ok\n", __func__);
}

void test_set_intersection(void)
{
        printf("%-30s ok\n", __func__);
}

void test_set_difference(void)
{
        printf("%-30s ok\n", __func__);
}

void test_set_is_member(void)
{
        printf("%-30s ok\n", __func__);
}

void test_set_is_subset(void)
{
        printf("%-30s ok\n", __func__);
}

void test_set_is_equal(void)
{
        printf("%-30s ok\n", __func__);
}

int compare(const void *value1, const void *value2)
{
        int v1 = *(int *) value1;
        int v2 = *(int *) value2;

        if (v1 < v2) {
                return -1;
        } else if (v1 > v2) {
                return 1;
        } else {
                return 0;
        }
}

void display_set(const set_t *set)
{
        if (set_size(set) == 0) {
                printf("empty\n");
                return;
        }
        for (node_t *node = list_head(set); node != NULL; node = list_next(node)) {
                printf("%d ", *(int *) list_data(node));
        }
        putchar('\n');
}

void create_set(set_t *set, int values[], size_t size)
{
        int *ptr = NULL;
        set_init(set, compare, free);
        for (size_t i = 0; i < size; i++) {
                ptr = (int *) malloc(sizeof(int));
                assert(ptr != NULL);
                assert(set_insert(set, (void *) ptr) != -1);
        }
}
